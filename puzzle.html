<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Colorful Puzzle</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            font-family: 'Varela Round', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        h1 {
            color: #555;
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 0px #fff;
        }

        #score-board {
            background: white;
            padding: 10px 30px;
            border-radius: 50px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 20px;
            font-weight: bold;
        }

        #score {
            color: #ff6b6b;
        }

        #game-container {
            position: relative;
            width: 400px;
            height: 400px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 5px;
        }

        .block {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            position: relative;
        }

        .block:hover {
            transform: scale(1.1);
            z-index: 10;
            filter: brightness(1.1);
        }

        .block.popping {
            animation: pop 0.3s forwards;
        }

        @keyframes pop {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }

            100% {
                transform: scale(0);
                opacity: 0;
            }
        }

        /* Colors */
        .color-0 {
            background: #ff6b6b;
            box-shadow: inset 0 -4px rgba(0, 0, 0, 0.1);
        }

        /* Red */
        .color-1 {
            background: #4ecdc4;
            box-shadow: inset 0 -4px rgba(0, 0, 0, 0.1);
        }

        /* Teal */
        .color-2 {
            background: #ffe66d;
            box-shadow: inset 0 -4px rgba(0, 0, 0, 0.1);
        }

        /* Yellow */
        .color-3 {
            background: #1a535c;
            box-shadow: inset 0 -4px rgba(0, 0, 0, 0.1);
        }

        /* Dark Blue */
        .color-4 {
            background: #ff9f43;
            box-shadow: inset 0 -4px rgba(0, 0, 0, 0.1);
        }

        /* Orange */

        /* Particles */
        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            pointer-events: none;
            animation: particle-anim 0.6s ease-out forwards;
            z-index: 100;
        }

        @keyframes particle-anim {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        #instructions {
            margin-top: 20px;
            color: #777;
            font-size: 1.1rem;
            text-align: center;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
        }

        /* Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.95);
            z-index: 1000;
            border-radius: 10px;
        }

        /* Title Screen */
        #title-screen {
            display: flex;
            /* Initially visible */
        }

        #title-screen h2 {
            font-size: 3rem;
            color: #4ecdc4;
            margin-bottom: 30px;
            text-shadow: 2px 2px #eee;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.5);
        }

        .btn:active {
            transform: translateY(1px);
        }

        /* Game Over */
        #game-over h2 {
            font-size: 3rem;
            color: #ff6b6b;
            margin: 0;
        }

        #game-over p {
            font-size: 1.5rem;
            color: #555;
        }

        /* Demo Mode */
        #demo-mode {
            background: rgba(0, 0, 0, 0.3);
            /* Darker for contrast */
            pointer-events: none;
        }

        #demo-text {
            font-size: 4rem;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
            transform: rotate(-15deg);
            animation: blink 1s infinite alternate;
        }

        #demo-subtext {
            margin-top: 20px;
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 0 0 5px #000;
            animation: pulse 2s infinite;
        }

        @keyframes blink {
            from {
                opacity: 1;
            }

            to {
                opacity: 0.5;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Varela+Round&display=swap" rel="stylesheet">
</head>

<body>

    <h1>Puzzle Pop!</h1>
    <div id="score-board">Score: <span id="score">0</span></div>

    <div style="position: relative;">
        <div id="game-container"></div>

        <!-- Title Screen -->
        <div id="title-screen" class="overlay">
            <h2>Puzzle Pop!</h2>
            <button class="btn" onclick="startGame()">Start Game</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over" class="overlay">
            <h2>GAME OVER</h2>
            <p>No more moves!</p>
            <button class="btn" onclick="returnToTitle()">Play Again</button>
        </div>

        <!-- Demo Mode Overlay -->
        <div id="demo-mode" class="overlay">
            <div id="demo-text">DEMO PLAY</div>
            <div id="demo-subtext">Click to Start</div>
        </div>
    </div>

    <div id="instructions">
        <p><strong>How to Play:</strong> Click on a group of <strong>3 or more</strong> blocks of the same color to pop
            them!</p>
    </div>

    <script>
        const ROWS = 8;
        const COLS = 8;
        const COLORS = 5;
        const container = document.getElementById('game-container');
        const scoreElement = document.getElementById('score');
        const titleScreen = document.getElementById('title-screen');
        const gameOverScreen = document.getElementById('game-over');
        const demoScreen = document.getElementById('demo-mode');

        let grid = [];
        let score = 0;
        let isAnimating = false;

        // Game State: 'TITLE', 'PLAYING', 'DEMO', 'GAMEOVER'
        let gameState = 'TITLE';
        let idleTimer;

        // Audio Context
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playPopSound(count) {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const baseFreq = 400 + (Math.min(count, 10) * 50);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 2, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1);
        }

        // Initialize Grid (used for both Demo and Game)
        function initGrid() {
            grid = [];
            do {
                grid = [];
                for (let r = 0; r < ROWS; r++) {
                    const row = [];
                    for (let c = 0; c < COLS; c++) {
                        row.push(Math.floor(Math.random() * COLORS));
                    }
                    grid.push(row);
                }
            } while (!hasValidMoves());
            render();
        }

        function render() {
            container.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const block = document.createElement('div');
                    block.className = `block color-${grid[r][c]}`;
                    block.dataset.r = r;
                    block.dataset.c = c;
                    block.onclick = () => handleClick(r, c);
                    container.appendChild(block);
                }
            }
        }

        // --- Game Flow Control ---

        function showTitle() {
            gameState = 'TITLE';
            titleScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            demoScreen.style.display = 'none';
            score = 0;
            scoreElement.innerText = score;
            initGrid(); // Show a grid in background
            resetIdleTimer();
        }

        function startGame() {
            gameState = 'PLAYING';
            titleScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            demoScreen.style.display = 'none';
            score = 0;
            scoreElement.innerText = score;
            initGrid();
            clearTimeout(idleTimer); // No demo in playing mode
        }

        function returnToTitle() {
            showTitle();
        }

        function startDemoMode() {
            if (gameState !== 'TITLE') return;
            gameState = 'DEMO';
            demoScreen.style.display = 'flex';
            demoLoop();
        }

        function stopDemoMode() {
            if (gameState === 'DEMO') {
                gameState = 'TITLE';
                demoScreen.style.display = 'none';
                // Don't reset grid, just let user see where demo left off or reset?
                // Usually attract mode resets when you start, but here we just go back to title
                resetIdleTimer();
            }
        }

        // --- Interaction ---

        function handleClick(r, c) {
            if (isAnimating) return;

            // If in Demo, any click stops demo
            if (gameState === 'DEMO') {
                stopDemoMode();
                return;
            }

            // If Title, click on background blocks does nothing (blocked by overlay), 
            // but if overlay is transparent enough or pointer-events allow...
            // Actually title overlay blocks clicks.

            if (gameState !== 'PLAYING' && gameState !== 'DEMO') return;

            // Logic for Playing/Demo
            const color = grid[r][c];
            const matches = findMatches(r, c, color);

            if (matches.length >= 3) {
                processMatch(matches, color);
            }
        }

        function processMatch(matches, color) {
            isAnimating = true;
            score += matches.length * 10;
            scoreElement.innerText = score;

            // Sound removed for office play
            // if (gameState !== 'DEMO') {
            //    playPopSound(matches.length);
            // }

            matches.forEach(({ r, c }) => {
                const index = r * COLS + c;
                const block = container.children[index];
                if (block) {
                    block.classList.add('popping');
                    const rect = block.getBoundingClientRect();
                    createParticles(rect, color);
                }
            });

            setTimeout(() => {
                removeMatches(matches);
                applyGravity();
                render();
                isAnimating = false;

                if (!hasValidMoves()) {
                    if (gameState === 'DEMO') {
                        initGrid(); // Restart demo
                    } else {
                        gameState = 'GAMEOVER';
                        gameOverScreen.style.display = 'flex';
                    }
                }
            }, 300);
        }

        // --- Core Logic ---

        function findMatches(r, c, color) {
            const matches = [];
            const visited = new Set();
            const queue = [{ r, c }];
            visited.add(`${r},${c}`);
            while (queue.length > 0) {
                const { r: currR, c: currC } = queue.shift();
                matches.push({ r: currR, c: currC });
                const directions = [{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }];
                for (const { dr, dc } of directions) {
                    const nr = currR + dr;
                    const nc = currC + dc;
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        const key = `${nr},${nc}`;
                        if (!visited.has(key) && grid[nr][nc] === color) {
                            visited.add(key);
                            queue.push({ r: nr, c: nc });
                        }
                    }
                }
            }
            return matches;
        }

        function removeMatches(matches) {
            for (const { r, c } of matches) {
                grid[r][c] = -1;
            }
        }

        function applyGravity() {
            for (let c = 0; c < COLS; c++) {
                let writeRow = ROWS - 1;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (grid[r][c] !== -1) {
                        grid[writeRow][c] = grid[r][c];
                        writeRow--;
                    }
                }
                while (writeRow >= 0) {
                    grid[writeRow][c] = Math.floor(Math.random() * COLORS);
                    writeRow--;
                }
            }
        }

        function hasValidMoves() {
            const visitedGlobal = new Set();
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const key = `${r},${c}`;
                    if (visitedGlobal.has(key)) continue;
                    const color = grid[r][c];
                    const matches = findMatches(r, c, color);
                    if (matches.length >= 3) return true;
                    matches.forEach(m => visitedGlobal.add(`${m.r},${m.c}`));
                }
            }
            return false;
        }

        function createParticles(rect, colorIndex) {
            const colorMap = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#1a535c', '#ff9f43'];
            const color = colorMap[colorIndex];
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.backgroundColor = color;
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                const angle = Math.random() * Math.PI * 2;
                const dist = 50 + Math.random() * 50;
                const tx = Math.cos(angle) * dist + 'px';
                const ty = Math.sin(angle) * dist + 'px';
                particle.style.setProperty('--tx', tx);
                particle.style.setProperty('--ty', ty);
                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 600);
            }
        }

        // --- Demo & Idle Logic ---

        function resetIdleTimer() {
            clearTimeout(idleTimer);
            if (gameState === 'DEMO') {
                stopDemoMode();
            }
            if (gameState === 'TITLE') {
                idleTimer = setTimeout(startDemoMode, 5000);
            }
        }

        function demoLoop() {
            if (gameState !== 'DEMO') return;

            if (!isAnimating) {
                const allMoves = [];
                const visitedGlobal = new Set();
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const key = `${r},${c}`;
                        if (visitedGlobal.has(key)) continue;
                        const matches = findMatches(r, c, grid[r][c]);
                        matches.forEach(m => visitedGlobal.add(`${m.r},${m.c}`));
                        if (matches.length >= 3) allMoves.push({ r, c });
                    }
                }

                if (allMoves.length > 0) {
                    const move = allMoves[Math.floor(Math.random() * allMoves.length)];
                    // Directly call processMatch to simulate click
                    processMatch(findMatches(move.r, move.c, grid[move.r][move.c]), grid[move.r][move.c]);
                } else {
                    initGrid();
                }
            }

            if (gameState === 'DEMO') {
                setTimeout(demoLoop, 1500);
            }
        }

        // Global Listeners
        window.addEventListener('mousemove', () => {
            if (gameState === 'DEMO') stopDemoMode();
            else if (gameState === 'TITLE') resetIdleTimer();
        });
        window.addEventListener('mousedown', () => {
            if (gameState === 'DEMO') stopDemoMode();
            else if (gameState === 'TITLE') resetIdleTimer();
        });
        window.addEventListener('keydown', () => {
            if (gameState === 'DEMO') stopDemoMode();
            else if (gameState === 'TITLE') resetIdleTimer();
        });

        // Start
        showTitle();

    </script>
</body>

</html>